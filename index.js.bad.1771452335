cat > index.js <<'EOF'
import express from "express";
import fetch from "node-fetch";
import dotenv from "dotenv";
import cors from "cors";

dotenv.config();

console.log("ðŸ”¥ THIS IS THE ACTIVE INDEX.JS FILE ðŸ”¥");

const app = express();
app.use(cors());
app.use(express.json());

app.get("/", (req, res) => res.status(200).send("Garnett Teaser API OK"));

const FINDING_COOLDOWN_MS = 3500;
let lastFindingCallAt = 0;

// tiny in-memory cache so we don't hammer Finding API
const CACHE = new Map();
function cacheGet(key) {
  const hit = CACHE.get(key);
  if (!hit) return null;
  if (Date.now() > hit.expiresAt) {
    CACHE.delete(key);
    return null;
  }
  return hit.value;
}
function cacheSet(key, value, ttlMs = 5 * 60 * 1000) {
  CACHE.set(key, { value, expiresAt: Date.now() + ttlMs });
}

function refuse(res, msg, retryAfterSec = 30) {
  return res.status(200).json({
    ok: false,
    verdict: "REFUSE",
    confidence: "THIN",
    error: msg,
    retryAfterSec,
  });
}

function extractItemId(text) {
  const s = String(text || "");
  const m1 = s.match(/\/itm\/(\d{12,14})/i);
  if (m1) return m1[1];
  const m2 = s.match(/(\d{12,14})/);
  return m2 ? m2[1] : null;
}

function cleanTitle(t) {
  if (!t) return "";
  return String(t)
    .replace(/&quot;/g, '"')
    .replace(/&#39;/g, "'")
    .replace(/&amp;/g, "&")
    .replace(/\s+/g, " ")
    .replace(/\s*[\|\-]\s*eBay\s*$/i, "")
    .trim();
}

function extractTitleFromHtml(html) {
  if (!html) return "";
  const og = html.match(/property=["']og:title["']\s+content=["']([^"']+)["']/i);
  if (og?.[1]) return cleanTitle(og[1]);

  const tt = html.match(/<title>\s*([^<]+)\s*<\/title>/i);
  if (tt?.[1]) return cleanTitle(tt[1]);

  return "";
}

async function fetchTitleFromListingHtml(listingUrl) {
  const html = await fetch(listingUrl, {
    headers: {
      "User-Agent":
        "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120 Safari/537.36",
      "Accept-Language": "en-US,en;q=0.9",
    },
  })
    .then((r) => r.text())
    .catch(() => "");

  const title = extractTitleFromHtml(html);
  if (!title) return "";

  // reject obvious block pages
  if (/error page|robot|security|access denied/i.test(title)) return "";

  return title;
}

function median(nums) {
  const arr = [...nums].sort((a, b) => a - b);
  if (!arr.length) return 0;
  const mid = Math.floor(arr.length / 2);
  return arr.length % 2 ? arr[mid] : (arr[mid - 1] + arr[mid]) / 2;
}

function confidenceFromComps(n) {
  if (n >= 20) return "HIGH";
  if (n >= 10) return "MED";
  if (n >= 5) return "LOW";
  return "THIN";
}

function normalizeKeywords(title) {
  // keep it simple: strip parentheses + punctuation, keep first ~7 words
  const cleaned = String(title)
    .replace(/\(.*?\)/g, " ")
    .replace(/[^a-zA-Z0-9\s]/g, " ")
    .replace(/\s+/g, " ")
    .trim();

  return cleaned.split(" ").slice(0, 7).join(" ");
}

async function callFinding(APP_ID, keywords) {
  // cooldown
  const now = Date.now();
  const since = now - lastFindingCallAt;
  if (since < FINDING_COOLDOWN_MS) {
    await new Promise((r) => setTimeout(r, FINDING_COOLDOWN_MS - since));
  }
  lastFindingCallAt = Date.now();

  const findingParams = new URLSearchParams({
    "OPERATION-NAME": "findCompletedItems",
    "SERVICE-VERSION": "1.13.0",
    "SECURITY-APPNAME": APP_ID,
    "RESPONSE-DATA-FORMAT": "JSON",
    "REST-PAYLOAD": "true",
    keywords,
    "itemFilter(0).name": "SoldItemsOnly",
    "itemFilter(0).value": "true",
    "paginationInput.entriesPerPage": "25",
  });

  const url = `https://svcs.ebay.com/services/search/FindingService/v1?${findingParams.toString()}`;
  const resp = await fetch(url, {
    headers: {
      "User-Agent":
        "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120 Safari/537.36",
    },
  });

  const text = await resp.text();

  // rate limit / blocks often return HTML or non-json
  let data;
  try {
    data = JSON.parse(text);
  } catch {
    data = { _raw: text.slice(0, 500) };
  }

  return { url, status: resp.status, data, rawFirst300: text.slice(0, 300) };
}

app.post("/teaser", async (req, res) => {
  try {
    const { listingUrl, buyPrice, condition } = req.body;

    const APP_ID = process.env.EBAY_APP_ID;
    if (!APP_ID) return res.status(500).json({ error: "Missing EBAY_APP_ID in .env" });

    const raw = String(listingUrl || "").trim();
    if (!raw) return res.status(400).json({ error: "Missing listingUrl" });

    const itemId = /^\d{12,14}$/.test(raw) ? raw : extractItemId(raw);
    if (!itemId) {
      return res.status(400).json({
        error:
          "Could not find Item ID. Paste full eBay URL containing /itm/ + 12â€“14 digits, or paste digits only.",
        received: raw,
      });
    }

    const buy = parseFloat(String(buyPrice ?? "").replace(/[^\d.]/g, "")) || 0;
    if (!buy || buy <= 0) return res.status(400).json({ error: "Invalid buyPrice" });

    const canonicalUrl = `https://www.ebay.com/itm/${itemId}`;

    // title cache
    const titleCacheKey = `title:${itemId}`;
    let title = cacheGet(titleCacheKey);
    if (!title) {
      title = await fetchTitleFromListingHtml(canonicalUrl);
      cacheSet(titleCacheKey, title || "", 10 * 60 * 1000);
    }

    if (!title) {
      return res.status(404).json({
        error:
          "Could not read title from listing page (ended listing or blocked page). Try a different LIVE item link.",
        itemId,
      });
    }

    const keywords = normalizeKeywords(title);

    // Finding cache (same keywords often repeated)
    const findingCacheKey = `finding:${keywords}`;
    let finding = cacheGet(findingCacheKey);
    if (!finding) {
      finding = await callFinding(APP_ID, keywords);
      cacheSet(findingCacheKey, finding, 2 * 60 * 1000);
    }

    // If blocked / rate limited
    if (finding.status === 429 || /rate limit/i.test(JSON.stringify(finding.data))) {
      return refuse(res, "eBay rate limit hit (Finding API). Wait 20â€“30 minutes and retry.", 1800);
    }

    const items =
      finding.data?.findCompletedItemsResponse?.[0]?.searchResult?.[0]?.item || [];

    const prices = items
      .map((it) =>
        parseFloat(it?.sellingStatus?.[0]?.convertedCurrentPrice?.[0]?.__value__)
      )
      .filter((n) => Number.isFinite(n) && n > 0);

    const compsCount = prices.length;
    const marketPrice = median(prices);
    const marginPct = ((marketPrice - buy) / buy) * 100;

    const verdict = marginPct >= 10 ? "PASS" : "FAIL";
    const confidence = confidenceFromComps(compsCount);

    return res.json({
      ok: true,
      verdict,
      confidence,
      marketPrice: Math.round(marketPrice),
      buyPrice: buy,
      marginPct: Math.round(marginPct),
      title,
      itemId,
      compsCount,
      condition: condition || "unknown",
      debug: {
        findingStatus: finding.status,
      },
    });
  } catch (e) {
    return res.status(500).json({ error: `Garnett Error: ${e.message}` });
  }
});

const PORT = process.env.PORT || 8080;
app.listen(PORT, "0.0.0.0", () => console.log(`âœ… Garnett Teaser API running on ${PORT}`));
EOF
thats ever
